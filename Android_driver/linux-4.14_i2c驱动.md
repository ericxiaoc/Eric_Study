###I2C标准驱动
``` c
#include <linux/module.h>
#include <linux/i2c.h>
#include <linux/bcd.h>
#include <linux/platform_device.h>
#include <linux/input.h>
#include <linux/miscdevice.h>
#include <linux/delay.h>
//#include <linux/wakelock.h>
#include <linux/slab.h>
#include <linux/interrupt.h>
#include <linux/workqueue.h>
#include <linux/of_gpio.h>
#include <linux/irqdomain.h>
#include <linux/uaccess.h>

#define C_I2C_FIFO_SIZE	 8

struct i2c_client * i2c_ntp8824_client = NULL;
static DEFINE_MUTEX(NTP8824_i2c_mutex);

static int ntp8824_i2c_read(struct i2c_client *client, u8 addr,
	u8 *data, u8 len)
{
	u8 beg = addr;
	int err;
	struct i2c_msg msgs[2] = {{0}, {0} };

	mutex_lock(&NTP8824_i2c_mutex);

	msgs[0].addr = client->addr;
	msgs[0].flags = 0;
	msgs[0].len = 1;
	msgs[0].buf = &beg;

	msgs[1].addr = client->addr;
	msgs[1].flags = I2C_M_RD;
	msgs[1].len = len;
	msgs[1].buf = data;

	if (!client) {
		mutex_unlock(&NTP8824_i2c_mutex);
		return -EINVAL;
	} else if (len > C_I2C_FIFO_SIZE) {
		printk(" length %d exceeds %d\n", len, C_I2C_FIFO_SIZE);
		mutex_unlock(&NTP8824_i2c_mutex);
	}
	err = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
	if (err != 2) {
		printk("i2c_transfer error: (%d %p %d) %d\n", addr, data,
			len, err);
		err = -EIO;
	} else
		err = 0;

	mutex_unlock(&NTP8824_i2c_mutex);

	return err;

}

static int ntp8824_i2c_write(struct i2c_client *client, u8 addr,
	u8 *data, u8 len)
{
	int err, idx, num = 0;
	char buf[C_I2C_FIFO_SIZE];

	udelay(2000);//批量写数据,出现偶尔失败的,可以加上这个延时试试

	mutex_lock(&NTP8824_i2c_mutex);
	if (!client) {
		mutex_unlock(&NTP8824_i2c_mutex);
		return -EINVAL;
	} else if (len >= C_I2C_FIFO_SIZE) {
		printk(" length %d exceeds %d\n", len, C_I2C_FIFO_SIZE);
		mutex_unlock(&NTP8824_i2c_mutex);
		return -EINVAL;
	}

	buf[num++] = addr;
	for (idx = 0; idx < len; idx++)
		buf[num++] = data[idx];

	printk("addr = 0x%x !!\n",buf[0]);

	err = i2c_master_send(client, buf, num);
	if (err < 0) {
		printk("send command error!!\n");
		mutex_lock(&NTP8824_i2c_mutex);
		return -EFAULT;
	}
	err = 0;
	mutex_unlock(&NTP8824_i2c_mutex);
	return err;
}

static int ntp8824_open(struct inode *inode, struct file *filp)
{
    return 0;
}

static int ntp8824_release(struct inode *inode, struct file *filp)
{
    return 0;
}

struct ntp8824_reg_data
{
	u8 reg;
	u8 data[4];
};

static struct ntp8824_reg_data ntp8824_init_data0[]=
{	//section0
	{0x02, 0x00},
	{0x33, 0x03},
	{0x7E, 0x03},
};

static struct ntp8824_reg_data ntp8824_init_data1[]=
{	//section1
	{0x32, {0x11,0x00,0x00,0x00}},
	{0x33, {0x20,0x00,0x00,0x00}},
	{0x34, {0x20,0x00,0x00,0x00}},
	{0x35, {0x20,0x00,0x00,0x00}},
	{0x36, {0x20,0x00,0x00,0x00}},
	{0x37, {0x11,0x00,0x00,0x00}},
	{0x38, {0x20,0x00,0x00,0x00}},
	{0x39, {0x20,0x00,0x00,0x00}},
	{0x3A, {0x20,0x00,0x00,0x00}},
	{0x3B, {0x20,0x00,0x00,0x00}},
	{0x3C, {0x11,0x00,0x00,0x00}},
	{0x3D, {0x20,0x00,0x00,0x00}},
	{0x3E, {0x20,0x00,0x00,0x00}},
	{0x3F, {0x20,0x00,0x00,0x00}},
	{0x40, {0x20,0x00,0x00,0x00}},
	{0x41, {0x11,0x00,0x00,0x00}},
	{0x42, {0x20,0x00,0x00,0x00}},
	{0x43, {0x20,0x00,0x00,0x00}},
	{0x44, {0x20,0x00,0x00,0x00}},
	{0x45, {0x20,0x00,0x00,0x00}},
	{0x46, {0x11,0x00,0x00,0x00}},
	{0x47, {0x20,0x00,0x00,0x00}},
	{0x48, {0x20,0x00,0x00,0x00}},
	{0x49, {0x20,0x00,0x00,0x00}},
	{0x4A, {0x20,0x00,0x00,0x00}},
	{0x4B, {0x11,0x00,0x00,0x00}},
	{0x4C, {0x20,0x00,0x00,0x00}},
	{0x4D, {0x20,0x00,0x00,0x00}},
	{0x4E, {0x20,0x00,0x00,0x00}},
	{0x4F, {0x20,0x00,0x00,0x00}},
};

static struct ntp8824_reg_data ntp8824_init_data2[]=
{	//section2
	{0x7E, 0x00},
	{0x33, 0x00},
	{0x20, 0x00},
	{0x21, 0x01},
	{0x22, 0x00},
	{0x23, 0x01},
	{0x26, 0x00},
	{0x27, 0x41},
	{0x2A, 0x6A},
	{0x2B, 0x01},
	{0x29, 0x08},
	{0x2C, 0x00},
	{0x17, 0x9F},
	{0x18, 0x9F},
	{0x43, 0x02},
	{0x3C, 0x64},
	{0x33, 0x03},
	{0x7E, 0x03},
};

static struct ntp8824_reg_data ntp8824_init_data3[]=
{	//section3
	{0x00, {0x11,0x00,0x00,0x00}},
	{0x01, {0x20,0x00,0x00,0x00}},
	{0x02, {0x20,0x00,0x00,0x00}},
	{0x03, {0x20,0x00,0x00,0x00}},
	{0x04, {0x20,0x00,0x00,0x00}},
	{0x05, {0x11,0x00,0x00,0x00}},
	{0x06, {0x20,0x00,0x00,0x00}},
	{0x07, {0x20,0x00,0x00,0x00}},
	{0x08, {0x20,0x00,0x00,0x00}},
	{0x09, {0x20,0x00,0x00,0x00}},
	{0x0A, {0x11,0x00,0x00,0x00}},
	{0x0B, {0x20,0x00,0x00,0x00}},
	{0x0C, {0x20,0x00,0x00,0x00}},
	{0x0D, {0x20,0x00,0x00,0x00}},
	{0x0E, {0x20,0x00,0x00,0x00}},
	{0x0F, {0x11,0x00,0x00,0x00}},
	{0x10, {0x20,0x00,0x00,0x00}},
	{0x11, {0x20,0x00,0x00,0x00}},
	{0x12, {0x20,0x00,0x00,0x00}},
	{0x13, {0x20,0x00,0x00,0x00}},
	{0x14, {0x11,0x00,0x00,0x00}},
	{0x15, {0x20,0x00,0x00,0x00}},
	{0x16, {0x20,0x00,0x00,0x00}},
	{0x17, {0x20,0x00,0x00,0x00}},
	{0x18, {0x20,0x00,0x00,0x00}},
	{0x19, {0x11,0x00,0x00,0x00}},
	{0x1A, {0x20,0x00,0x00,0x00}},
	{0x1B, {0x20,0x00,0x00,0x00}},
	{0x1C, {0x20,0x00,0x00,0x00}},
	{0x1D, {0x20,0x00,0x00,0x00}},
	{0x1E, {0x11,0x00,0x00,0x00}},
	{0x1F, {0x20,0x00,0x00,0x00}},
	{0x20, {0x20,0x00,0x00,0x00}},
	{0x21, {0x20,0x00,0x00,0x00}},
	{0x22, {0x20,0x00,0x00,0x00}},
	{0x23, {0x11,0x00,0x00,0x00}},
	{0x24, {0x20,0x00,0x00,0x00}},
	{0x25, {0x20,0x00,0x00,0x00}},
	{0x26, {0x20,0x00,0x00,0x00}},
	{0x27, {0x20,0x00,0x00,0x00}},
	{0x28, {0x11,0x00,0x00,0x00}},
	{0x29, {0x20,0x00,0x00,0x00}},
	{0x2A, {0x20,0x00,0x00,0x00}},
	{0x2B, {0x20,0x00,0x00,0x00}},
	{0x2C, {0x20,0x00,0x00,0x00}},
	{0x2D, {0x11,0x00,0x00,0x00}},
	{0x2E, {0x20,0x00,0x00,0x00}},
	{0x2F, {0x20,0x00,0x00,0x00}},
	{0x30, {0x20,0x00,0x00,0x00}},
	{0x31, {0x20,0x00,0x00,0x00}},
	{0x5C, {0x11,0x00,0x00,0x00}},
	{0x5D, {0x20,0x00,0x00,0x00}},
	{0x5E, {0x20,0x00,0x00,0x00}},
	{0x5F, {0x20,0x00,0x00,0x00}},
	{0x60, {0x20,0x00,0x00,0x00}},
	{0x61, {0x11,0x00,0x00,0x00}},
	{0x62, {0x20,0x00,0x00,0x00}},
	{0x63, {0x20,0x00,0x00,0x00}},
	{0x64, {0x20,0x00,0x00,0x00}},
	{0x65, {0x20,0x00,0x00,0x00}},
	{0x66, {0x11,0x00,0x00,0x00}},
	{0x67, {0x20,0x00,0x00,0x00}},
	{0x68, {0x20,0x00,0x00,0x00}},
	{0x69, {0x20,0x00,0x00,0x00}},
	{0x6A, {0x20,0x00,0x00,0x00}},
	{0x6B, {0x11,0x00,0x00,0x00}},
	{0x6C, {0x20,0x00,0x00,0x00}},
	{0x6D, {0x20,0x00,0x00,0x00}},
	{0x6E, {0x20,0x00,0x00,0x00}},
	{0x6F, {0x20,0x00,0x00,0x00}},
	{0x70, {0x11,0x00,0x00,0x00}},
	{0x71, {0x20,0x00,0x00,0x00}},
	{0x72, {0x20,0x00,0x00,0x00}},
	{0x73, {0x20,0x00,0x00,0x00}},
	{0x74, {0x20,0x00,0x00,0x00}},
	{0x75, {0x11,0x00,0x00,0x00}},
	{0x76, {0x20,0x00,0x00,0x00}},
	{0x77, {0x20,0x00,0x00,0x00}},
	{0x78, {0x20,0x00,0x00,0x00}},
	{0x79, {0x20,0x00,0x00,0x00}},
};

static struct ntp8824_reg_data ntp8824_init_data4[]=
{	//section4
	{0x7E, 0x08},
};

static struct ntp8824_reg_data ntp8824_init_data5[]=
{	//section5
	{0x00, {0x10,0x00,0x00,0x00}},
	{0x01, {0x10,0x00,0x00,0x00}},
	{0x02, {0x10,0x00,0x00,0x00}},
	{0x03, {0x10,0x00,0x00,0x00}},
	{0x04, {0x10,0x00,0x00,0x00}},
	{0x05, {0x10,0x00,0x00,0x00}},
	{0x06, {0x11,0x00,0x00,0x00}},
	{0x07, {0x11,0x00,0x00,0x00}},
	{0x08, {0x11,0x00,0x00,0x00}},
	{0x09, {0x11,0x00,0x00,0x00}},
	{0x0A, {0x11,0x00,0x00,0x00}},
	{0x0B, {0x11,0x00,0x00,0x00}},
	{0x0C, {0x11,0x00,0x00,0x00}},
	{0x0D, {0x11,0x00,0x00,0x00}},
	{0x0E, {0x11,0x00,0x00,0x00}},
	{0x0F, {0x11,0x00,0x00,0x00}},
	{0x10, {0x11,0x00,0x00,0x00}},
	{0x11, {0x11,0x00,0x00,0x00}},
	{0x12, {0x20,0x00,0x00,0x00}},
	{0x13, {0x20,0x00,0x00,0x00}},
	{0x14, {0x20,0x00,0x00,0x00}},
	{0x15, {0x20,0x00,0x00,0x00}},
	{0x16, {0x20,0x00,0x00,0x00}},
	{0x17, {0x20,0x00,0x00,0x00}},
	{0x1F, {0x11,0x00,0x00,0x00}},
	{0x20, {0x11,0x00,0x00,0x00}},
	{0x21, {0x11,0x00,0x00,0x00}},
	{0x22, {0x11,0x00,0x00,0x00}},
	{0x23, {0x11,0x00,0x00,0x00}},
	{0x24, {0x11,0x00,0x00,0x00}},
};

static struct ntp8824_reg_data ntp8824_init_data6[]=
{	//section6
	{0x7E, 0x00},
	{0x33, 0x00},
	{0x19, 0x04},
	{0x1A, 0x00},
	{0x1B, 0x00},
	{0x1C, 0x00},
	{0x1D, 0x00},
	{0x1E, 0x00},
	{0x1F, 0x00},
	{0x0E, 0x00},
	{0x0F, 0x00},
	{0x10, 0x00},
	{0x11, 0x00},
	{0x12, 0x00},
	{0x13, 0x00},
	{0x14, 0x00},
	{0x15, 0x00},
	{0x68, 0x00},
	{0x24, 0x00},
	{0x25, 0x0A},
	{0x4D, 0x0A},
	{0x4E, 0x0A},
	{0x4F, 0x0A},
	{0x2D, 0x0A},
	{0x07, 0x00},
};

static struct ntp8824_reg_data ntp8824_init_data7[]=
{	//section7
	{0x00, 0x00},
	{0x01, 0x00},
	{0x38, 0x0B},
	{0x34, 0x00},
	{0x35, 0x00},
	{0x41, 0x1A},
	{0x44, 0x0E},
	{0x76, 0x70},
	{0x03, 0x4E},
	{0x04, 0x00},
	{0x05, 0x00},
	{0x06, 0x4E},
};

static struct ntp8824_reg_data ntp8824_init_data8[]=
{	//section8
	{0x3D, 0x00},
	{0x0C, 0xFF},
	{0x16, 0x00},
	{0x35, 0x00},
	{0x34, 0x00},
	{0x33, 0x00},
};

static struct ntp8824_reg_data ntp8824_init_rst[]=
{	//soft rst
	{0x0B, 0x01},
};

static struct ntp8824_reg_data ntp8824_init_test[]=
{	//
	{0x02, 0x00},
	{0x00, 0x00},
	{0x5D, 0x01},
	{0x17, 0x9F},
	{0x18, 0x9F},
	{0x3C, 0x64},
	{0x43, 0x02},
	{0x4A, 0x00},
	{0x76, 0x70},
	{0x44, 0x0E},
	{0x68, 0x00},
	{0x0C, 0xFF},	//open
	{0x34, 0x00},
	{0x35, 0x00},
};

int ntp8824_init_data(struct i2c_client *client, u8* version)
{

		int i,ret=0;
		u8 read_data[2] = {0};
		printk("%s start.\n",__func__);
		//ret = ntp8824_i2c_write(client,ntp8824_init_rst[0].reg,ntp8824_init_rst[0].data,1);//soft reset
		//mdelay(500);
		for(i=0;(i<ARRAY_SIZE(ntp8824_init_data0));i++){
			 ret = ntp8824_i2c_write(client,ntp8824_init_data0[i].reg,ntp8824_init_data0[i].data,1);
		}

		for(i=0;(i<ARRAY_SIZE(ntp8824_init_data1));i++){
			 ret = ntp8824_i2c_write(client,ntp8824_init_data1[i].reg,ntp8824_init_data1[i].data,4);
		}

		for(i=0;(i<ARRAY_SIZE(ntp8824_init_data2));i++){
			 ret = ntp8824_i2c_write(client,ntp8824_init_data2[i].reg,ntp8824_init_data2[i].data,1);
		}

		for(i=0;(i<ARRAY_SIZE(ntp8824_init_data3));i++){
			 ret = ntp8824_i2c_write(client,ntp8824_init_data3[i].reg,ntp8824_init_data3[i].data,4);
		}

		for(i=0;(i<ARRAY_SIZE(ntp8824_init_data4));i++){
			 ret = ntp8824_i2c_write(client,ntp8824_init_data4[i].reg,ntp8824_init_data4[i].data,1);
		}

		for(i=0;(i<ARRAY_SIZE(ntp8824_init_data5));i++){
			 ret = ntp8824_i2c_write(client,ntp8824_init_data5[i].reg,ntp8824_init_data5[i].data,4);
		}

		for(i=0;(i<ARRAY_SIZE(ntp8824_init_data6));i++){
			 ret = ntp8824_i2c_write(client,ntp8824_init_data6[i].reg,ntp8824_init_data6[i].data,1);
		}

		for(i=0;(i<ARRAY_SIZE(ntp8824_init_data7));i++){
			 ret = ntp8824_i2c_write(client,ntp8824_init_data7[i].reg,ntp8824_init_data7[i].data,1);
		}

		for(i=0;(i<ARRAY_SIZE(ntp8824_init_data8));i++){
			 ret = ntp8824_i2c_write(client,ntp8824_init_data8[i].reg,ntp8824_init_data8[i].data,1);
		}
/*read write test*/
#if 0
		//init reg
		for(i=0;(i<ARRAY_SIZE(ntp8824_init_test));i++){
			 ret = ntp8824_i2c_write(client,ntp8824_init_test[i].reg,ntp8824_init_test[i].data,0x01);
		}
		//read
		for(i=0;(i<ARRAY_SIZE(ntp8824_init_test));i++){
			 ret = ntp8824_i2c_read(client,ntp8824_init_test[i].reg,read_data,0x01);
			 printk("read_data = %x \n",read_data[0]);
		}
#endif
    return 0;
}


static const struct file_operations ntp8824_fops = {
    .owner = THIS_MODULE,
    //.unlocked_ioctl = ntp8824_ioctl,
    .open = ntp8824_open,
    .release = ntp8824_release
};

static struct miscdevice ntp8824_dev = {
    .minor = MISC_DYNAMIC_MINOR,
    .name = "ntp8824_i2c",
    .fops = &ntp8824_fops
};

struct pinctrl* pinctr_rst;
struct pinctrl_state* rst_gpio_low, *rst_gpio_high;

static int ntp8824_probe(struct i2c_client *client, const struct i2c_device_id *id)
{
		int err = 0;
		int ret = 0;
		unsigned char version_info;
		struct device_node *np = client->dev.of_node;
		unsigned int rst_gpio;

		printk("%s (%d) : probe module\n", __func__, __LINE__);

		if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
		{
			err = -EIO;
			return err;
		}

		i2c_ntp8824_client = client;

		pinctr_rst = devm_pinctrl_get(&client->dev);

		rst_gpio_low = pinctrl_lookup_state(pinctr_rst, "rst_gpio_low");

		rst_gpio_high = pinctrl_lookup_state(pinctr_rst, "rst_gpio_high");

		pinctrl_select_state(pinctr_rst, rst_gpio_high);
		mdelay(10);
		pinctrl_select_state(pinctr_rst, rst_gpio_low);
		mdelay(5);
		pinctrl_select_state(pinctr_rst, rst_gpio_high);
		mdelay(10);

	//	err = misc_register(&ntp8824_dev);

/*		rst_gpio = of_get_named_gpio(np, "rst_gpio", 0);
		if (rst_gpio < 0) {
				printk("%s() Can not get rst_gpio\n", __func__);
				goto err;
		}else{
				ret = gpio_request(rst_gpio, "rst_gpio");
				if (ret < 0) {
						printk("%s() Can not request rst_gpio\n", __func__);
						goto err;
				}
				printk("ntp88824 get rst_gpio = %d \n",rst_gpio);
				gpio_direction_output(rst_gpio,1);
				mdelay(500);
				gpio_direction_output(rst_gpio,0);
				mdelay(500);
				gpio_direction_output(rst_gpio,1);
				mdelay(500);
		}*/

		ret = ntp8824_init_data(client, &version_info);
		if (ret < 0)
    {
        printk("Read version failed \n");
    }else{
    	 printk("Read version success \n");
    }
		return 0;
	err:
		return -1;
}

static int ntp8824_remove(struct i2c_client *client)
{
		return 0;
}

static int ntp8824_suspend(struct device *dev)
{
		return 0;
}

static int ntp8824_resume(struct device *dev)
{
		return 0;
}

static const struct i2c_device_id ntp8824_id[] = {
	{ "ntp8824", 0 },
	{ }
};
MODULE_DEVICE_TABLE(i2c, ntp8824_id);

static const struct dev_pm_ops ntp8824_pm_ops = {
	.suspend = ntp8824_suspend,
	.resume = ntp8824_resume
};

static struct of_device_id ntp8824_dt_ids[] = {
	{ .compatible = "sz99du,ntp8824" },
	{},
};

struct i2c_driver ntp8824_driver = {
	.driver		= {
		.name	= "ntp8824",
		.owner	= THIS_MODULE,
		.of_match_table = of_match_ptr(ntp8824_dt_ids),
		.pm = &ntp8824_pm_ops},
	.probe		= ntp8824_probe,
	.remove		= ntp8824_remove,
	.id_table	= ntp8824_id,
};

static int __init ntp8824_init(void)
{
		printk("%s (%d) : init module\n", __func__, __LINE__);
		return i2c_add_driver(&ntp8824_driver);
}

static void __exit ntp8824_exit(void)
{
		printk("%s (%d) : exit module\n", __func__, __LINE__);
		i2c_del_driver(&ntp8824_driver);
}

MODULE_AUTHOR("eric caojie@99dugd.com");
MODULE_DESCRIPTION("ntp8824 audio driver");
MODULE_LICENSE("GPL");

late_initcall(ntp8824_init);
module_exit(ntp8824_exit);
```
